<?php
/**
 * This file was generated by the ConvertToLegacy class in bronto-legacy.
 * The purpose of the conversion was to maintain PSR-0 compliance while
 * the main development focuses on modern styles found in PSR-4.
 *
 * For the original:
 * @see src/Bronto/Api.php
 */


/**
 * Library entry point and complete wrapper around the SPL SoapClient.
 *
 * @author Philip Cali <philip.cali@bronto.com>
 */
class Bronto_Api
{
    const BASE_URI = 'http://api.bronto.com/v4';
    private $_options;
    private $_token;
    private $_soapClient;
    private $_authenticated = false;

    /**
     * @param string $token
     * @param array|Options (Optional)
     */
    public function __construct($token, $options = null)
    {
        $this->_token = $token;
        if (is_null($options)) {
            $this->_options = new Bronto_Api_Options();
        } else if (is_array($options)) {
            $this->_options = new Bronto_Api_Options($options);
        } else if ($options instanceof Bronto_Api_Options) {
            $this->_options = $options;
        } else {
            throw new InvalidArgumentException(sprintf('$options must either be an array or Bronto_Api_Options: %s given', $options));
        }
    }

    /**
     * Authenticates the SoapClient
     *
     * @return string
     */
    public function login()
    {
        $apiToken = $this->_token;
        $sessionId = $this->getSoapClient()->login(array('apiToken' => $apiToken))->return;
        $this->_options->safeObserver()->each(function($observer) use ($apiToken, $sessionId) {
            $observer->onLogin($apiToken, $sessionId);
        });
        $this->setSessionId($sessionId);
        return $sessionId;
    }

    /**
     * If an existing session ID is available, register it with the client
     *
     * @param string $sessionId
     * @return Api
     */
    public function setSessionId($sessionId)
    {
        $this->getSoapClient()->__setSoapHeaders(array(new SoapHeader(self::BASE_URI, 'sessionHeader', array('sessionId' => $sessionId))));
        $this->_authenticated = true;
        return $this;
    }

    /**
     * Executes an API request that have at least the following information:
     *
     * - method: string method if the SOAP function
     * - data: data container for the SOAP function
     *
     * @param Object $request
     * @return stdClass
     */
    public function execute(Bronto_Object $request)
    {
        $tries = 0;
        $maxTries = $this->_options->getRetries();
        $method = $request->getMethod();
        $data = $request->getData();
        if ($data instanceof Bronto_Object) {
            $data = $data->toArray();
        }
        do {
            try {
                if (!$this->isAuthenticated()) {
                    $this->login();
                }
                return $this->getSoapClient()->$method($data);
            } catch (Exception $e) {
                $tries++;
                $api = $this;
                $exception = new Bronto_Api_Exception($e->getMessage(), $e->getCode(), $e, $tries, $request);
                $this->_options
                    ->safeError()
                    ->filter(function($error) use ($exception, $api, $request) {
                        // Filter on a recoverable strategy
                        return $error->recover($exception, $api, $request);
                    })
                    ->orElse(function() use ($exception, $api, $request) {
                        // A write failed due to network reasons... store it
                        if ($request->hasUpdates() && $exception->isNetworkRelated()) {
                            $this->_options->safeRetryer(function($retryer) use ($request, $api) {
                                $retryer->store($request, $api->getToken());
                            });
                        }
                        $api->getOptions()
                            ->safeObserver()->each(function($observer) use ($api, $exception) {
                                $observer->onError($api, $exception);
                            });
                        throw $exception;
                    });
            }
        } while ($tries < $maxTries);
        // It should never reach here, but we'll safely terminate
        throw new Bronto_Api_Exception("Max attempts have been reached.");
    }

    /**
     * To be used solely as a convenience to $api->transfer('Object')
     *
     * @param string $name
     * @param array $arguments
     * @return Bronto_Api_Operation
     */
    public function __call($name, $arguments)
    {
        if (preg_match('/^transfer(.*)/', $name, $match)) {
            return $this->transfer($match[1]);
        }
        throw new BadMethodCallException("Method {$name} does not exist.");
    }

    /**
     * Create an operation object that wraps all CRUD requests
     *
     * @param string $object
     * @param array $methods (Optional)
     * @return Bronto_Api_Operation
     */
    public function transfer($object, array $methods = null)
    {
        $tempClass = "Bronto_Api_Operation_{$object}";
        // Note: This snippet was generated with legacy conversion
        if (is_string($tempClass) && !array_key_exists($tempClass, Bronto_ImportManager::$_fileCache)) {
            $dir = str_replace(str_replace("_", "/", "Bronto"), '', dirname(__FILE__));
            $file = $dir . str_replace("_", "/", $tempClass) . '.php';
            if (file_exists($file)) {
                require_once $file;
                Bronto_ImportManager::$_fileCache[$tempClass] = true;
            } else {
                Bronto_ImportManager::$_fileCache[$tempClass] = false;
            }
        }
        // End Conversion Snippet
        if (Bronto_ImportManager::$_fileCache[$tempClass]) {
            return new $tempClass($this);
        }
        return new Bronto_Api_Operation($this, $object, $methods);
    }

    /**
     * @return Bronto_Api_Options
     */
    public function getOptions()
    {
        return $this->_options;
    }

    /**
     * @return boolean
     */
    public function isAuthenticated()
    {
        return $this->_authenticated;
    }

    /**
     * If trace is flagged, will return the last SOAP request
     *
     * @return string
     */
    public function getLastRequest()
    {
        return $this->getSoapClient()->__getLastRequest();
    }

    /**
     * If trace is flagged, will return the last headers sent
     *
     * @return string
     */
    public function getLastRequestHeaders()
    {
        return $this->getSoapClient()->__getLastRequestHeaders();
    }

    /**
     * If trace is flagged, will return the last raw response
     *
     * @return string
     */
    public function getLastResponse()
    {
        return $this->getSoapClient()->__getLastResponse();
    }

    /**
     * If trace is flagged, will return the last response headers
     *
     * @return string
     */
    public function getLastResponseHeaders()
    {
        return $this->getSoapClient()->__getLastResponseHeaders();
    }

    /**
     * APIv4 token used
     *
     * @return string
     */
    public function getToken()
    {
        return $this->_token;
    }

    /**
     * Gets or creates the underlying SoapClient used to make calls
     *
     * @return SoapClient
     */
    public function getSoapClient()
    {
        if (is_null($this->_soapClient)) {
            $options = $this->_options;
            $soapClient = $this->_options->safeSoapClient()->orElse(function() use ($options) {
                $soapClass = $options->getSoapClass();
                return new $soapClass($options->getWsdl(), $options->getSoapOptions());
            });
            $this->_soapClient = $soapClient->get();
        }
        return $this->_soapClient;
    }

    /**
     * Fields necesary to deserialize the API wrapper
     *
     * @return array
     */
    public function __sleep()
    {
        return array('_token', '_options');
    }
}
